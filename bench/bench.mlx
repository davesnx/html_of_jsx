(* html_of_jsx benchmarks
   
   Measures render latency (µs per render) for various scenarios.
   
   Usage:
     dune exec bench/bench.exe                    # Human-readable output
     dune exec bench/bench.exe -- --json          # JSON output for CI
     dune exec bench/bench.exe -- --compare FILE  # Compare with baseline
*)

(* Command line arguments *)
let json_mode = ref false
let compare_file = ref None

let parse_args () =
  let args = Array.to_list Sys.argv in
  let rec parse = function
    | [] -> ()
    | "--json" :: rest ->
        json_mode := true;
        parse rest
    | "--compare" :: file :: rest ->
        compare_file := Some file;
        parse rest
    | _ :: rest -> parse rest
  in
  parse (List.tl args)

(* Benchmark result type *)
type result = {
  name : string;
  latency_us : float; (* microseconds per render *)
  ops_sec : float; (* operations per second *)
}

(* Extract average rate from benchmark samples *)
let extract_rate samples =
  let total_rate =
    List.fold_left
      (fun acc sample ->
        let rate =
          Int64.to_float sample.Benchmark.iters /. sample.Benchmark.wall
        in
        acc +. rate)
      0.0 samples
  in
  total_rate /. float_of_int (List.length samples)

(* Run a single benchmark and return result *)
let run_bench ~name ~render =
  let samples =
    Benchmark.throughputN ~style:Benchmark.Nil ~repeat:3 2
      [ (name, render, ()) ]
  in
  let ops_sec = match samples with [ (_, s) ] -> extract_rate s | _ -> 0.0 in
  let latency_us = if ops_sec > 0.0 then 1_000_000.0 /. ops_sec else 0.0 in
  { name; latency_us; ops_sec }

(* All scenarios to benchmark *)
let scenarios =
  [
    (* Realistic pages *)
    ("Trivial", Scenarios.Trivial.render);
    ("Dashboard", Scenarios.Dashboard.render);
    ("Blog (50 comments)", Scenarios.Blog.render);
    ("Table (100 rows)", Scenarios.Table.render);
    ("E-commerce", Scenarios.Ecommerce.render);
    ("Form", Scenarios.Form.render);
    (* Synthetic stress tests *)
    ("Deep tree (50)", Scenarios.DeepTree.render);
    ("Wide tree (100)", Scenarios.WideTree.render);
    ("Shallow tree", Scenarios.ShallowTree.render);
    ("Props heavy", Scenarios.PropsHeavy.render);
  ]

(* Micro-benchmarks for escape function *)
let escape_benchmarks =
  [
    ( "escape (clean)",
      fun () ->
        let buf = Buffer.create 128 in
        JSX.escape buf "Hello, World!";
        ignore (Buffer.contents buf) );
    ( "escape (dirty)",
      fun () ->
        let buf = Buffer.create 128 in
        JSX.escape buf "<script>alert('XSS')</script>";
        ignore (Buffer.contents buf) );
  ]

(* JSON output *)
let results_to_json results =
  let items =
    List.map
      (fun r ->
        Printf.sprintf
          {|  {"name": "%s", "latency_us": %.2f, "ops_sec": %.2f, "unit": "ops/sec", "value": %.2f}|}
          r.name r.latency_us r.ops_sec r.ops_sec)
      results
  in
  "[\n" ^ String.concat ",\n" items ^ "\n]"

(* Parse baseline JSON file - handles both old and new format *)
let parse_baseline filename =
  let ic = open_in filename in
  let content = really_input_string ic (in_channel_length ic) in
  close_in ic;
  let results = Hashtbl.create 20 in
  let lines = String.split_on_char '\n' content in
  List.iter
    (fun line ->
      if String.contains line '"' && String.contains line ':' then
        try
          (* Find "name": "..." *)
          let name_start = String.index line '"' + 1 in
          let name_end = String.index_from line name_start '"' in
          let key = String.sub line name_start (name_end - name_start) in
          if key = "name" then
            (* Get the actual name value *)
            let colon = String.index_from line name_end ':' in
            let val_start = String.index_from line colon '"' + 1 in
            let val_end = String.index_from line val_start '"' in
            let raw_name = String.sub line val_start (val_end - val_start) in

            (* Normalize name: strip prefix like "scenario/" or "escape/" *)
            let name =
              if
                String.length raw_name > 9
                && String.sub raw_name 0 9 = "scenario/"
              then String.sub raw_name 9 (String.length raw_name - 9)
              else if
                String.length raw_name > 7
                && String.sub raw_name 0 7 = "escape/"
              then String.sub raw_name 7 (String.length raw_name - 7)
              else raw_name
            in

            (* Map old names to new names *)
            let name =
              match name with
              | "trivial" -> "Trivial"
              | "dashboard" -> "Dashboard"
              | "blog" -> "Blog (50 comments)"
              | "table" -> "Table (100 rows)"
              | "ecommerce" -> "E-commerce"
              | "form" -> "Form"
              | "deep_tree" -> "Deep tree (50)"
              | "wide_tree" -> "Wide tree (100)"
              | "shallow_tree" -> "Shallow tree"
              | "props_heavy" -> "Props heavy"
              | "escape_clean" -> "escape (clean)"
              | "escape_dirty" -> "escape (dirty)"
              | other -> other
            in

            (* Try to find latency_us first (new format) *)
            let latency =
              try
                let idx = Str.search_forward (Str.regexp "latency_us") line 0 in
                let colon = String.index_from line idx ':' in
                let start = ref (colon + 1) in
                while !start < String.length line && line.[!start] = ' ' do
                  incr start
                done;
                let end_pos = ref !start in
                while
                  !end_pos < String.length line
                  &&
                  let c = line.[!end_pos] in
                  (c >= '0' && c <= '9') || c = '.'
                do
                  incr end_pos
                done;
                Some
                  (float_of_string (String.sub line !start (!end_pos - !start)))
              with Not_found | Invalid_argument _ | Failure _ -> None
            in

            (* If no latency_us, try to find "value" (old format with ops/sec) *)
            let latency =
              match latency with
              | Some l -> Some l
              | None -> (
                  try
                    let idx =
                      Str.search_forward (Str.regexp "\"value\"") line 0
                    in
                    let colon = String.index_from line idx ':' in
                    let start = ref (colon + 1) in
                    while !start < String.length line && line.[!start] = ' ' do
                      incr start
                    done;
                    let end_pos = ref !start in
                    while
                      !end_pos < String.length line
                      &&
                      let c = line.[!end_pos] in
                      (c >= '0' && c <= '9') || c = '.'
                    do
                      incr end_pos
                    done;
                    let ops_sec =
                      float_of_string
                        (String.sub line !start (!end_pos - !start))
                    in
                    (* Convert ops/sec to latency_us *)
                    Some (1_000_000.0 /. ops_sec)
                  with Not_found | Invalid_argument _ | Failure _ -> None)
            in

            match latency with
            | Some l -> Hashtbl.add results name l
            | None -> ()
        with _ -> ())
    lines;
  results

(* Format latency for display *)
let format_latency us =
  if us < 1.0 then Printf.sprintf "%.2f" us
  else if us < 10.0 then Printf.sprintf "%.1f" us
  else Printf.sprintf "%.0f" us

(* Format change percentage *)
let format_change baseline current =
  let pct = (current -. baseline) /. baseline *. 100.0 in
  if pct > 5.0 then Printf.sprintf "    +%.1f%%" pct
  else if pct < -5.0 then Printf.sprintf "✓   %.1f%%" pct
  else if pct > 0.0 then Printf.sprintf "    +%.1f%%" pct
  else Printf.sprintf "    %.1f%%" pct

(* Human-readable output *)
let print_results results baseline =
  print_endline "=== html_of_jsx benchmark ===\n";
  let has_baseline = Hashtbl.length baseline > 0 in
  if has_baseline then (
    Printf.printf "%-28s %12s    %s\n" "Scenario" "Time (µs)" "vs baseline";
    print_endline (String.make 56 '-'))
  else (
    Printf.printf "%-28s %12s\n" "Scenario" "Time (µs)";
    print_endline (String.make 44 '-'));
  List.iter
    (fun r ->
      let time_str = format_latency r.latency_us in
      if has_baseline then
        match Hashtbl.find_opt baseline r.name with
        | Some base_latency ->
            let change = format_change base_latency r.latency_us in
            Printf.printf "%-28s %12s %s\n" r.name time_str change
        | None -> Printf.printf "%-28s %12s     NEW\n" r.name time_str
      else Printf.printf "%-28s %12s\n" r.name time_str)
    results;
  if has_baseline then print_endline (String.make 56 '-')
  else print_endline (String.make 44 '-')

(* Count improvements/regressions *)
let summarize results baseline =
  if Hashtbl.length baseline = 0 then ()
  else
    let improved = ref 0 in
    let regressed = ref 0 in
    let unchanged = ref 0 in
    List.iter
      (fun r ->
        match Hashtbl.find_opt baseline r.name with
        | Some base_latency ->
            let pct = (r.latency_us -. base_latency) /. base_latency *. 100.0 in
            if pct < -5.0 then incr improved
            else if pct > 5.0 then incr regressed
            else incr unchanged
        | None -> ())
      results;
    Printf.printf "\nSummary: %d improved (>5%%), %d regressed, %d unchanged\n"
      !improved !regressed !unchanged

let () =
  parse_args ();

  (* Load baseline if specified *)
  let baseline =
    match !compare_file with
    | Some file -> parse_baseline file
    | None -> Hashtbl.create 0
  in

  (* Run scenario benchmarks *)
  let scenario_results =
    List.map (fun (name, render) -> run_bench ~name ~render) scenarios
  in

  (* Run escape micro-benchmarks *)
  let escape_results =
    List.map (fun (name, render) -> run_bench ~name ~render) escape_benchmarks
  in

  let all_results = scenario_results @ escape_results in

  if !json_mode then print_endline (results_to_json all_results)
  else (
    print_results scenario_results baseline;
    print_newline ();
    print_results escape_results baseline;
    summarize all_results baseline)
